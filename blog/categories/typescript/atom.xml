<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: typescript | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/typescript/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2022-04-12T02:05:11+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Context to Simplify a VERY Large React Form]]></title>
    <link href="https://artsy.github.io/blog/2022/02/01/using-context-to-simplify-a-react-form/"/>
    <updated>2022-02-01T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2022/02/01/using-context-to-simplify-a-react-form</id>
    <content type="html"><![CDATA[<p>For those unfamiliar, Artsy is a fine art marketplace. Knowing that, it follows logically to say that the form via
which our partners list artworks for sale is an integral part of Artsy’s core systems. This form, known only as
“The Artwork Form,” is whispered about in the halls of Arty’s New York headquarters. It is legendary. It is a
colossus. It is old enough not only to predate React v16.8 hooks and context APIs, but Artsy’s use of React
entirely. The first version of the Artwork Form was built in 2014 using ruby and haml, and began its refactoring
into JS/JQuery/React a full 2 years later, after having expanded considerably from the original implementation.
That process (at least what we’ve gleaned from our git excavation) was incremental, experimental, and passed
through many hands before it landed in the lap of the current Partner Experience (PX) team.</p>

<!-- more -->

<p>PX has since been tasked with the maintenance of this unwieldy kaiju, spending endless amounts of time on seemingly
insignificant changes to behavior or UI, all while watching its performance degrade. Many of the people reading
this are already familiar with the story we’re telling. Many have worked in their very own version of the tale, and
borne witness to the fact that legacy code of this scale becomes a living, breathing entity. The developers that
tend these beasts learn their patterns and idiosyncrasies, their little moans and groans, and for the sake of
expediency work within those constraints to accomplish their tasks. But when is enough, enough? When does the
developer time expended working within the constraints of an obsolete design begin to outweigh the time it would
take to simply <em>fix</em> <em>the code</em>?</p>

<p>First, let’s be honest: there is no single right answer to this question. When working in software development we
have to deal with certain realities: user experience vs. developer experience, lead time to the next release,
buy-in from stakeholders, etc. These factors may weigh more or less depending on the shop and the product. At Artsy
we’re very lucky, in that our engineering department is given the time to attend to our tech debt and to be
deliberate about when and how we go about this. In the case of the Artwork Form, there were several issues that had
become too glaring to ignore:</p>

<ol>
  <li>The data coming in, and subsequently being passed to individual components, was being completely obscured by the
amount of prop drilling and spreading that existed within the composed form.</li>
  <li>The prolific use of <code class="language-plaintext highlighter-rouge">any</code> when typing data was disabling typescript and consequently removing its usefulness
while still imposing all of its burdens.</li>
  <li>The components within the form were tightly coupled, the number and specificity of props needed for each
disallowing reuse in other parts of the app.</li>
</ol>

<p>A few of us on the PX team decided to take matters into our own hands and address some of these key problems with
the Artwork Form. We came up with a plan to incrementally convert the form to use values from the Formik context,
use these values wherever possible to reduce prop-drilling, add much more complete types to the components to get
rid of all the <code class="language-plaintext highlighter-rouge">any</code>’s, and update some of our testing strategies as needed.</p>

<p>Here are the steps we took to do this conversion:</p>

<ol>
  <li>
    <p>Create a hook that allows us to use the Formik context throughout the form</p>

    <p>The hook wraps <a href="https://formik.org/docs/api/useFormikContext"><code class="language-plaintext highlighter-rouge">useFormikContext</code></a> to allow all of our components
inside of Formik to access the values from Formik context. It looks like this:</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nx">useArtworkForm</span><span class="p">():</span> <span class="nx">FormikContextType</span><span class="o">&lt;</span><span class="nx">ArtworkValues</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">formikContext</span> <span class="o">=</span> <span class="nx">useFormikContext</span><span class="o">&lt;</span><span class="nx">ArtworkValues</span><span class="o">&gt;</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">formikContext</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>We use <code class="language-plaintext highlighter-rouge">ArtworkValues</code> as the generic type so that when we are accessing <code class="language-plaintext highlighter-rouge">values</code> anywhere inside the component
tree, <code class="language-plaintext highlighter-rouge">values</code> can be type-checked.</p>
  </li>
  <li>Convert all of the components in the form to functional components and to TypeScript. (Because the form is
several years old, there were still many class components and many components that were not yet using
TypeScript.) This step could be done in parallel with Step 1. One note here is that when converting files from
JavaScript to TypeScript, we did not explicitly type the props in an interface. Once we can take advantage of
our <code class="language-plaintext highlighter-rouge">useArtworkForm</code> hook, we will reduce the amount of props needed in each component, so we will hold off on
typing the props until step 3.</li>
  <li>
    <p>The bulk of the work was making use of the <code class="language-plaintext highlighter-rouge">useArtworkForm</code> hook in the Artwork Form components. Starting with
the lowest leaves of the component tree and moving up, we removed the <code class="language-plaintext highlighter-rouge">props</code> from the component definition and
destructured any values we needed in the component from the <code class="language-plaintext highlighter-rouge">useArtworkForm</code> hook. Once we used everything we
could from the context, we added back in any additional props that we would still need to have passed down from
the parent. In many cases, this was no props at all—a particularly satisfying case. If the component still
needed props passed down, we explicitly typed the props at the top of each component in an interface because we
now knew exactly which props we would need inside of the component. Another key step here was going into the
parent component and getting rid of any prop spreading (this: <code class="language-plaintext highlighter-rouge">...props</code>) and instead explicitly passing down
exactly the props needed in the component (if there were any).</p>

    <ol>
      <li>A note on tests: Whenever we took advantage of the Formik context in a component, we were breaking that
component’s tests, because the wrappers we were using in the tests did not have access to the Formik context
and were being passed props that the component was no longer looking at. We created a helper test wrapper
that we could use in all of our Artwork Form tests to wrap the test’s specific wrapper inside of a
<code class="language-plaintext highlighter-rouge">&lt;Formik/&gt;</code> component and provide the specific <code class="language-plaintext highlighter-rouge">values</code> to use as the initial values for <code class="language-plaintext highlighter-rouge">Formik</code>. Many of
our test cases involve passing different <code class="language-plaintext highlighter-rouge">values</code> into the component, which we originally did via props but
now will do via the Formik context through the wrapper. Here’s what the wrapper looks like:</li>
    </ol>

    <div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">TestFormikWrapper</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">FC</span><span class="o">&lt;</span><span class="nx">TestFormikWrapperProps</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">values</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">props</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">Formik</span> <span class="na">initialValues</span><span class="p">=</span><span class="si">{</span><span class="nx">values</span><span class="si">}</span> <span class="na">onSubmit</span><span class="p">=</span><span class="si">{</span><span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">()</span><span class="si">}</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">children</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nc">Formik</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>Here is an example of <code class="language-plaintext highlighter-rouge">TestFormikWrapper</code> used in a test:</p>

    <div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">describe</span><span class="p">(</span><span class="dl">"</span><span class="s2">TestComponent</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">displays values</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nx">mount</span><span class="p">(</span>
      <span class="p">&lt;</span><span class="nc">TestFormikWrapper</span> <span class="na">values</span><span class="p">=</span><span class="si">{</span><span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Andy Warhol</span><span class="dl">"</span> <span class="p">}</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">TestComponent</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nc">TestFormikWrapper</span><span class="p">&gt;</span>
    <span class="p">)</span>

    <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">wrapper</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">#name</span><span class="dl">"</span><span class="p">).</span><span class="nx">html</span><span class="p">()</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">name</span><span class="p">).</span><span class="nx">toInclude</span><span class="p">(</span><span class="dl">"</span><span class="s2">Andy Warhol</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div>    </div>
  </li>
  <li>Once we completed the conversion all the way up the tree to the root component, the <code class="language-plaintext highlighter-rouge">ArtworkForm</code>, we typed that
component as strictly as possible and made sure to get rid of <code class="language-plaintext highlighter-rouge">any</code>’s. There were quite a few when we started
the process.</li>
</ol>

<p>So, where did we end up? Now all of the components in the Artwork Form are making use of the <code class="language-plaintext highlighter-rouge">useArtworkForm</code> hook
if they were previously accessing any of the values from the Formik context from props. We have much less prop
drilling between components and instead explicitly pass down the props needed from parent to child. It’s now much
more clear for developers what data is passing between the components and what data is actually being used in the
child. All of the components are also explicitly typed so we know exactly which props, if any, need to be passed
down from the parent. If any of these props are removed, TypeScript helps us by failing loudly.</p>

<p>One of the main pain points of the Artwork Form is that it’s very difficult for new developers (whether new to
Artsy or new to the Partner Experience team) to contribute and make changes to the form without breaking something
or spending extra time figuring out how data is passed within the form. Hopefully, this change will make it easier
for developers to understand the Artwork From.</p>

<p>How did the Artwork Form get so complicated? Well, as we shared, the Artwork Form is the key to achieving one of
the PX team’s core goals: surfacing the most accurate and rich information about artworks to collectors. We have to
allow partners to add more and increasingly specific pieces of metadata to artworks. The form has been growing and
for better or worse, will need to keep growing. Even though we expect to grow the form to meet metadata needs, we
do not put too much focus on the UX/UI of the Artwork Form in order to prioritize our collector-facing apps. (The
Artwork Form is only used by a relatively small subset of users, mostly gallery partners.) Hopefully, this refactor
will allow us to expand the form more seamlessly and will make it easier to navigate as it grows.</p>

<p>This refactor is still in its early days. The next steps for making the form easier to use (for both developers and
our end users) will require larger changes. When we think about further progress on revamping the Artwork Form, our
team is considering breaking the form up into smaller forms. Imagine, we are rendering several different top-level
<code class="language-plaintext highlighter-rouge">Formik</code> components that include discrete sections of the form, instead of just one giant <code class="language-plaintext highlighter-rouge">Formik</code> tree as we have
now. We would then combine these “mini forms” together, making better use of React’s core principle of composition.</p>

<p>Breaking up the form would be a big change for the developer experience (but hopefully made easier by this
refactor). It could also involve big changes to the UI. The Artwork Form is not just hard to navigate for
developers. It’s hard for users too. Over the next couple of months, our Product Manager will be working with one
of Artsy’s user researchers to conduct user testing on the form. Feedback from galleries will help determine where
we next take this project. We’re excited to have buy-in from our product team to work on a project that will
elevate the user experience while allowing us to use that opportunity to improve the developer experience as well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is TypeScript?]]></title>
    <link href="https://artsy.github.io/blog/2019/04/05/omakase-typescript/"/>
    <updated>2019-04-05T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/04/05/omakase-typescript</id>
    <content type="html"><![CDATA[<p>TypeScript is a language from Microsoft which builds on JavaScript. This post is a non-technical overview of what
JavaScript is, how TypeScript extends JavaScript and why we choose to adopt TypeScript at Artsy.</p>

<!-- more -->

<h2 id="what-is-javascript">What is JavaScript?</h2>

<p>First up, you can’t describe TypeScript without talking about JavaScript. To create a website (and a bunch of other
types of things) you work in three languages: HTML, CSS and JavaScript (JS). Broadly speaking: HTML defines the
content that will appear on the page, CSS defines the visual style of the page, and JS defines the interactive
behaviours of the page.</p>

<p>We describe having these sets of skills as being a “front-end” developer. You have to understand those three
languages to present anything inside a web browser like Safari, Firefox or Chrome. So, given how popular the web
is, there is a massive demand for people who are good at using these three languages.</p>

<p>There is also the set of skills for the “back-end” developers, which are to create computer services that
communicate either to a web browser (by passing it HTML/CSS/JS) or to another service (by sending a raw data.) You
don’t need to use HTML, CSS or JS to write this type of code, but it’s usually an end-product of your work. We
mostly build our back-ends in Ruby or JavaScript at Artsy.</p>

<h3 id="what-do-programming-languages-do">What do Programming Languages do?</h3>

<p>Programming languages are an interesting problem to solve. People read code many, many multiples of times more than
they write it - so developers create languages which are good at solving particular problems with a small amount of
code. Here’s an example using JavaScript:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Danger</span><span class="dl">"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">name</span><span class="p">)</span>
</code></pre></div></div>

<p>The first line makes a variable (a kind of box you can keep things in) and then the second line outputs text to the
console (think DOS, or the terminal) <code class="language-plaintext highlighter-rouge">"Hello, Danger"</code>. JavaScript is designed to work as a scripting language,
which means the code starts at the top of the file and then goes through line by line. To provide some contrast,
here is the <a href="https://repl.it/repls/VioletredGlisteningInfo">same behavior</a> in Java, which is built with different
language constraints:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Danger"</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<blockquote>
  <p>Note: if you find the naming of Java and JavaScript confusing, it is (they are two completely separate
programming languages, no link at all.) JavaScript was <a href="https://medium.com/@benastontweet/lesson-1a-the-history-of-javascript-8c1ce3bffb17">named that way</a> because Java was looking to be
really the next hot language (it did turn out that way for a decade or two, but now JavaScript is usually the
first language people have heard of.)</p>
</blockquote>

<p>Aside from having a lot more lines, the Java version comes with a lot of words that aren’t necessarily about
telling the computer exactly what to do, e.g. <code class="language-plaintext highlighter-rouge">class Main {</code>, <code class="language-plaintext highlighter-rouge">public static void main(String[] args) {</code>, <code class="language-plaintext highlighter-rouge">}</code> and
<code class="language-plaintext highlighter-rouge">}</code> again. It also has semi-colons at the end of some lines. Java is aimed at building different things from
JavaScript, and these extra bits of code make sense within the constraints of building a Java app.</p>

<p>To get to my main point though, there is one standout line I’d like us to compare:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// JavaScript
var name = "Danger"
// Java
String name = "Danger";
</code></pre></div></div>

<p>Both of these lines declare variables called <code class="language-plaintext highlighter-rouge">name</code> which contain the value <code class="language-plaintext highlighter-rouge">"Danger"</code>.</p>

<p>In JavaScript you use the abbreviation <code class="language-plaintext highlighter-rouge">var</code> to declare a variable. Meanwhile, in Java you need to say <em>what kind
of data</em> the variable contains. In this case the variable contains a <code class="language-plaintext highlighter-rouge">String</code>. (A string is a programming term for
a collection of characters. They <code class="language-plaintext highlighter-rouge">"look like this"</code>. This <a href="https://www.youtube.com/watch?v=czTWbdwbt7E">5m video</a>
is a good primer if you want to learn more.)</p>

<p>Both of these variables contain a string, but the difference is that in Java the variable can <em>only</em> ever contain a
<em>string</em>, because that’s what we said when we created the variable. In JS the variable can change to be <em>anything</em>,
like a number, or a list of dates.</p>

<p>To illustrate:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Before in JS</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Danger</span><span class="dl">"</span>
<span class="c1">// Also OK</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="mi">1</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="kc">false</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">2018-02-03</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">2019-01-12</span><span class="dl">"</span><span class="p">]</span>

<span class="c1">// Before in Java</span>
<span class="nb">String</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Danger</span><span class="dl">"</span><span class="p">;</span>
<span class="c1">// Not OK, the code wouldn't be accepted by Java</span>
<span class="nb">String</span> <span class="nx">name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">String</span> <span class="nx">name</span> <span class="o">=</span> <span class="kc">false</span>
<span class="nb">String</span> <span class="nx">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">[]{</span><span class="dl">"</span><span class="s2">2018-02-03</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">2019-01-12</span><span class="dl">"</span><span class="p">};</span>
</code></pre></div></div>

<p>These trade-offs make sense in the context for which these languages were built back in 1995. JavaScript was
originally designed to be a small programming language which handled simple interactions on websites. Java on the
other hand was built specifically to make big apps which could run on any computer. Their needs had different
scales, so the language required programmers write different types of code.</p>

<p>Java required programmers to be more explicit with the values of their variables because the programs they expected
people to build were more complex. While JavaScript opted for ease of reading, and aimed to do less.</p>

<h3 id="what-is-typescript">What is TypeScript?</h3>

<p>TypeScript is a programming language - it contains all of JavaScript, and then a bit more. Using our example above,
let’s compare the scripts for “Hello, Danger” in JavaScript vs TypeScript:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JavaScript</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Danger</span><span class="dl">"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">name</span><span class="p">)</span>

<span class="c1">// TypeScript</span>
<span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Danger</span><span class="dl">"</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello, </span><span class="dl">"</span> <span class="o">+</span> <span class="nx">name</span><span class="p">)</span>

<span class="c1">// Yep, you're not missing something, there's no difference</span>
</code></pre></div></div>

<p>Due to TypeScript’s aim to only <em>extend</em> JavaScript, your normal JavaScript code should work fine with TypeScript.
The things TypeScript adds to JavaScript are intended to help you be more explicit about what kinds of data are
used in your code, a bit like Java.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">- var name = "Danger"
</span><span class="gi">+ var name: string = "Danger"
</span><span class="p">console.log("Hello, " + danger)
</span></code></pre></div></div>

<p>This extra <code class="language-plaintext highlighter-rouge">: string</code> allow the reader to be certain that <code class="language-plaintext highlighter-rouge">name</code> will only be a string. Annotating your variables
also gives TypeScript the chance to verify this for you. This is <em>very</em> useful because keeping track of changes
like the type of value in a variable seems easy when it’s one or two, but once it starts hitting the hundreds,
that’s a lot to keep track of. Types help programmers be more confident about their code because types catch
mistakes.</p>

<p>Simply speaking, we call these annotations “Types”. Hence the name <i>Type</i>Script. The tag-line for TypeScript
is “JavaScript which scales” which is a statement that these extra type annotations allows you to work on bigger
projects. This is because you can verify up-front how correct your code is. This means you have less need to
understand how every change affects the rest of the program.</p>

<p>In the 90s, and maybe until a 5-10 years ago the trade-off for not having types in your JavaScript application was
fine because the size and complexities of the programs being built were constrained to just the front-end of
websites. Today though, JavaScript is being used everywhere:</p>

<ul>
  <li>Apps like Slack, or Spotify for your computer are built in mostly JavaScript</li>
  <li>Some iOS apps, including Artsy’s are mostly JavaScript</li>
  <li>The back-end and front-end of Artsy.net are JavaScript</li>
</ul>

<p>These are all considerably more complicated to build and understand, adding types drastically reduces the
complexity of making improvements to those programs.</p>

<h3 id="why-does-artsy-use-typescript">Why does Artsy use TypeScript?</h3>

<p>Artsy definitely isn’t the size of Microsoft! Artsy is about 30 engineers, and Microsoft are about 60,000. However,
some of our problems are the same. Developers at Artsy build apps which are made up of thousands of files. A change
to one individual file can affect the behaviour of any number of other files, like throwing a pebble into a pond
and causing ripples to spread out to the bank.</p>

<p>Typically, the need to ensure there are no bugs is less of a problem for people building websites. Websites are
easy to make changes to, because if you change the site - everyone gets the update instantly. We also build our iOS
app with JavaScript, but a change to our app requires Apple to review the changes and for users to download the new
version from the App Store.</p>

<p>This means that the iOS team needs to have more checks that everything is OK before shipping the app to the world.
Using TypeScript gives our team the ability to feel good that the changes we have made are only the changes we
want.</p>

<p>TypeScript isn’t the only programming language to tackle the problem of making JavaScript code safer, but it’s the
one with the biggest community, allows people to re-use their JavaScript knowledge, can be added in small steps,
and has really good tools to help developers work faster.</p>

<p>These qualities made it worth adding an extra tool to our developers’ toolbelt, and we’re not the only ones because
TypeScript is growing to be <a href="https://www.wired.com/story/typescript-microsoft-javascript-alternative-most-popular">one of the most popular programming languages in the world</a> with almost 6
million downloads a week.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[From TSLint to ESLint, or How I Learned to Lint GraphQL Code]]></title>
    <link href="https://artsy.github.io/blog/2019/01/29/from-tslint-to-eslint/"/>
    <updated>2019-01-29T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/01/29/from-tslint-to-eslint</id>
    <content type="html"><![CDATA[<p>At the beginning of January we discovered an interesting note in <a href="https://github.com/Microsoft/TypeScript/issues/29288">TypeScript’s roadmap</a> about linting:</p>

<blockquote>
  <p>In a survey we ran in VS Code a few months back, the most frequent theme we heard from users was that the linting
experience left much to be desired. Since part of our team is dedicated to editing experiences in JavaScript, our
editor team set out to add support for both TSLint and ESLint. However, we noticed that there were a few
architectural issues with the way TSLint rules operate that impacted performance. Fixing TSLint to operate more
efficiently would require a different API which would break existing rules (unless an interop API was built like
what wotan provides).</p>
</blockquote>

<blockquote>
  <p>Meanwhile, ESLint already has the more-performant architecture we’re looking for from a linter. Additionally,
different communities of users often have lint rules (e.g. rules for React Hooks or Vue) that are built for
ESLint, but not TSLint.</p>
</blockquote>

<blockquote>
  <p>Given this, our editor team will be focusing on leveraging ESLint rather than duplicating work. For scenarios
that ESLint currently doesn’t cover (e.g. semantic linting or program-wide linting), we’ll be working on sending
contributions to bring ESLint’s TypeScript support to parity with TSLint. As an initial testbed of how this works
in practice, we’ll be switching the TypeScript repository over to using ESLint, and sending any new rules
upstream.</p>
</blockquote>

<p>At Artsy we’ve been using TSLint for a few years now; it’s worked well for us, and we’ve even written our own
<a href="https://github.com/relay-tools/tslint-plugin-relay">custom rules</a>. However, given the vastness of the JS ecosystem
and how fast it moves, it’s easy to recognize this announcement as an exciting moment for tooling simplicity.</p>

<!-- more -->

<p>To give an example, anyone who has built a culture around Airbnb’s
<a href="https://github.com/airbnb/javascript">JavaScript style guide</a> will instantly recognize the conundrum they’re in
when migrating to TypeScript:</p>

<p><img width="100%" alt="a reddit user discovers their linting rules no longer work" src="https://user-images.githubusercontent.com/236943/51884369-d845b380-233b-11e9-9d2f-102cc8a3a78b.png" /></p>

<p>This means that teams maintaining legacy JavaScript codebases will no longer have to <em>also</em> maintain
<a href="https://github.com/palantir/tslint-react">two</a> <a href="https://github.com/yannickcr/eslint-plugin-react">versions</a> of often nearly <a href="https://github.com/prettier/tslint-plugin-prettier">identical</a>
<a href="https://github.com/prettier/prettier-eslint">rule-sets</a>. All of the aggregate culture that builds up around linting can now be shared in a
forward and backward facing way, making the often-daunting process of migrating a codebase from JavaScript to
TypeScript a much easier sell.</p>

<p>With this in mind we wanted to give the new officially-sanctioned <a href="https://github.com/typescript-eslint/typescript-eslint">typescript-eslint</a> project a
spin and document our findings.</p>

<h3 id="setup">Setup</h3>

<p>To get started, install the necessary dependencies:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>yarn <span class="nb">install</span> <span class="nt">-D</span> eslint typescript @typescript-eslint/eslint-plugin
</code></pre></div></div>

<p>Then create a new <code class="language-plaintext highlighter-rouge">.eslintrc.js</code> and add a bit of setup:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">parser</span><span class="p">:</span> <span class="dl">"</span><span class="s2">@typescript-eslint/parser</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">@typescript-eslint</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">extends</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">eslint:recommended</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">plugin:@typescript-eslint/recommended</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">parserOptions</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">ecmaVersion</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
    <span class="na">project</span><span class="p">:</span> <span class="dl">"</span><span class="s2">./tsconfig.json</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">sourceType</span><span class="p">:</span> <span class="dl">"</span><span class="s2">module</span><span class="dl">"</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">parserOptions.project</code> points to your <code class="language-plaintext highlighter-rouge">tsconfig.json</code> file:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"compilerOptions"</span><span class="p">:</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Next, add a bit of TypeScript to a file</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s2">"export const foo: any = 'bar'"</span> <span class="o">&gt;</span> index.ts
</code></pre></div></div>

<p>and run the linter:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>yarn eslint <span class="nb">.</span> <span class="nt">--ext</span> .ts,.tsx

~/index.ts
  1:12  warning  Unexpected any. Specify a different <span class="nb">type</span>  @typescript-eslint/no-explicit-any

✖ 1 problem <span class="o">(</span>0 errors, 1 warnings<span class="o">)</span>
</code></pre></div></div>

<p>Very nice!</p>

<p>Now lets expand the example a bit and add something more sophisticated, which in Artsy’s use-case is commonly
GraphQL:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>yarn add <span class="nt">-D</span> eslint-plugin-graphql graphql-tag apollo
</code></pre></div></div>

<p>Update <code class="language-plaintext highlighter-rouge">tsconfig.json</code> and let it know we’ll be using <code class="language-plaintext highlighter-rouge">node</code> for imports:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"compilerOptions"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"moduleResolution"</span><span class="p">:</span><span class="w"> </span><span class="s2">"node"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">.eslintrc.js</code> add these rules (while noting the addition of <code class="language-plaintext highlighter-rouge">graphql</code> to <code class="language-plaintext highlighter-rouge">plugins</code> and
<code class="language-plaintext highlighter-rouge">graphql/template-strings</code> under <code class="language-plaintext highlighter-rouge">rules</code>):</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">path</span><span class="dl">"</span><span class="p">)</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">parser</span><span class="p">:</span> <span class="dl">"</span><span class="s2">@typescript-eslint/parser</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">plugins</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">@typescript-eslint</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">graphql</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">extends</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">eslint:recommended</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">plugin:@typescript-eslint/recommended</span><span class="dl">"</span><span class="p">],</span>
  <span class="na">parserOptions</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">ecmaVersion</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
    <span class="na">project</span><span class="p">:</span> <span class="dl">"</span><span class="s2">./tsconfig.json</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">sourceType</span><span class="p">:</span> <span class="dl">"</span><span class="s2">module</span><span class="dl">"</span>
  <span class="p">},</span>
  <span class="na">rules</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">graphql/template-strings</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span>
      <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">,</span>
      <span class="p">{</span>
        <span class="na">schemaJsonFilepath</span><span class="p">:</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">__dirname</span><span class="p">,</span> <span class="dl">"</span><span class="s2">./schema.json</span><span class="dl">"</span><span class="p">),</span>
        <span class="na">tagName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">graphql</span><span class="dl">"</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For GraphQL to know what to lint, we’ll need a schema. Thankfully the
<a href="https://etmdb.com/graphql">Ethiopian Movie Database</a> has our back :)</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>yarn apollo service:download <span class="nt">--endpoint</span> https://etmdb.com/graphql
  ✔ Loading Apollo Project
  ✔ Saving schema to schema.json
✨  Done <span class="k">in </span>2.18s.
</code></pre></div></div>

<p>Back in <code class="language-plaintext highlighter-rouge">index.ts</code>, add this bit of code:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">graphql</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">graphql-tag</span><span class="dl">"</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">MovieQuery</span> <span class="o">=</span> <span class="nx">graphql</span><span class="s2">`
  query MoveQuery {
    allCinemaDetails(before: "2017-10-04", after: "2010-01-01") {
      edges {
        nodez {
          slug
          hallName
        }
      }
    }
  }
`</span>
</code></pre></div></div>

<p>And run the linter:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>yarn eslint <span class="nb">.</span> <span class="nt">--ext</span> .ts,.tsx

~/index.ts
  7:9  error  Cannot query field <span class="s2">"nodez"</span> on <span class="nb">type</span> <span class="s2">"CinemaDetailNodeEdge"</span><span class="nb">.</span> Did you mean <span class="s2">"node"</span>?  graphql/template-strings

✖ 1 problem <span class="o">(</span>1 error, 0 warnings<span class="o">)</span>
</code></pre></div></div>

<p>Ahh yes, I meant <a href="https://i.redd.it/tfugj4n3l6ez.png"><code class="language-plaintext highlighter-rouge">node</code></a>.</p>

<h3 id="bonus-vscode-integration">Bonus: VSCode Integration</h3>

<p>As developers, we like our tools to work for us, and in 2019 the tool that <em>seems</em> to do that best just happens to
be a brilliant open source product from Microsoft. There were a couple unexpected configuration issues when we were
setting this up, but thankfully they’re easy fixes.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> .vscode <span class="o">&amp;&amp;</span> <span class="nb">touch</span> .vscode/settings.json
</code></pre></div></div>

<p>Then add a couple settings:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"editor.formatOnSave"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="nl">"eslint.autoFixOnSave"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="nl">"eslint.validate"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"language"</span><span class="p">:</span><span class="w"> </span><span class="s2">"javascript"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"autoFix"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"language"</span><span class="p">:</span><span class="w"> </span><span class="s2">"javascriptreact"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"autoFix"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"language"</span><span class="p">:</span><span class="w"> </span><span class="s2">"typescript"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"autoFix"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"language"</span><span class="p">:</span><span class="w"> </span><span class="s2">"typescriptreact"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"autoFix"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"tslint.enable"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Format on save, fix on save, <em>autofix</em> on save, tell ESLint to recognize <code class="language-plaintext highlighter-rouge">.ts</code> (and <code class="language-plaintext highlighter-rouge">.tsx</code>, for the React folks)
then disable <code class="language-plaintext highlighter-rouge">tslint</code> so that <code class="language-plaintext highlighter-rouge">eslint</code> can do its thing:</p>

<p><img width="698" alt="eslint displaying graphql error in VSCode IDE" src="https://user-images.githubusercontent.com/236943/51884366-d380ff80-233b-11e9-8128-6c39e210dd31.png" /></p>

<p>Now ESLint will show you right where your GraphQL error is from within VSCode. Pretty sweet.</p>

<p>Be sure to read <a href="https://eslint.org/blog/2019/01/future-typescript-eslint">The future of TypeScript on ESLint</a> for more details.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Conditional types in TypeScript]]></title>
    <link href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/"/>
    <updated>2018-11-21T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript</id>
    <content type="html"><![CDATA[<p>This year TypeScript gained a new feature that punches far above its weight.</p>

<blockquote>
  <p>Working through our (enormous) backlog of unsorted TypeScript “Suggestions” and it’s remarkable how many of them
are solved by conditional types.</p>
</blockquote>

<p>– <a href="https://twitter.com/SeaRyanC/status/1029846761718702081">Ryan Cavanaugh</a>, TypeScript maintainer</p>

<p>Conditional types probably aren’t something you’ll write every day, but you might end up using them indirectly all
the time. That’s because they’re great for ‘plumbing’ or ‘framework’ code, for dealing with API boundaries and
other behind-the-scenes kinda stuff. So, dear reader, read on! It’s always good to learn how the sausage is made.
Then you can make sausage of your own.</p>

<p>Typewurst! 🌭</p>

<!-- more -->

<p><em>Note: This is a straightforward adaptation of a 35-minute presentation given at
<a href="https://www.meetup.com/Futurice-London-Beer-Tech/events/255295412/">Futurice London’s TypeScript Night meetup</a>,
and therefore provides more context than an ordinary blog post might. I hope a lot of that context is interesting
and useful even for seasoned TypeScript developers. If you’d prefer a no-frills experience, check out the
<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html">TypeScript 2.8 Release notes</a> .</em></p>

<h2 id="your-first-conditional-type">Your first conditional type</h2>

<p>Here’s some plain JavaScript</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">text</span> <span class="o">&amp;&amp;</span> <span class="nx">text</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/f/g</span><span class="p">,</span> <span class="dl">"</span><span class="s2">p</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">process</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">()</span>
</code></pre></div></div>

<p>Reading the code, it’s clear to a human that the <code class="language-plaintext highlighter-rouge">.toUpperCase()</code> method call is safe. We can tell that whenever a
string is passed in to <code class="language-plaintext highlighter-rouge">process</code>, a string will be returned.</p>

<p>But notice that we could also pass something like <code class="language-plaintext highlighter-rouge">null</code> into the function, in which case <code class="language-plaintext highlighter-rouge">null</code> would be returned.
Then calling <code class="language-plaintext highlighter-rouge">.toUpperCase()</code> on the result would be an error.</p>

<p>Let’s add basic types to this function so we can let TypeScript worry about whether we are using it safely or not.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">text</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">):</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">text</span> <span class="o">&amp;&amp;</span> <span class="nx">text</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/f/g</span><span class="p">,</span> <span class="dl">"</span><span class="s2">p</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Seems sensible. What happens if we try to use it like before?</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//            ⌄ Type Error! :(</span>
<span class="nx">process</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">()</span>
</code></pre></div></div>

<p>TypeScript complains because it thinks that the result of <code class="language-plaintext highlighter-rouge">process("foo")</code> might be <code class="language-plaintext highlighter-rouge">null</code>, even though we clever
humans know that it won’t be. It can’t figure out the runtime semantics of the function on its own.</p>

<p>One way of helping TS understand the function better is to use ‘overloading’. Overloading involves providing
multiple type signatures for a single function, and letting TypeScript figure out which one to use in any given
context.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">text</span><span class="p">:</span> <span class="kc">null</span><span class="p">):</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">text</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">process</span><span class="p">(</span><span class="nx">text</span><span class="p">:</span> <span class="kr">any</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here we’ve said that if we pass a <code class="language-plaintext highlighter-rouge">string</code>, it returns a <code class="language-plaintext highlighter-rouge">string</code>, and if we pass <code class="language-plaintext highlighter-rouge">null</code>, it returns <code class="language-plaintext highlighter-rouge">null</code>. <em>(The
<code class="language-plaintext highlighter-rouge">any</code> type is ignored but still needs to be there for some reason</em> 🤷‍️<em>)</em></p>

<p>That works nicely:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// All clear!</span>
<span class="nx">process</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">()</span>
<span class="c1">//           ⌄ Type Error! :)</span>
<span class="nx">process</span><span class="p">(</span><span class="kc">null</span><span class="p">).</span><span class="nx">toUpperCase</span><span class="p">()</span>
</code></pre></div></div>

<p>But there’s another use case that doesn’t work:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">declare</span> <span class="kd">const</span> <span class="nx">maybeFoo</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span>

<span class="c1">//      ⌄ Type Error! :(</span>
<span class="nx">process</span><span class="p">(</span><span class="nx">maybeFoo</span><span class="p">)</span>
</code></pre></div></div>

<p>TypeScript won’t let us pass something that is of type <code class="language-plaintext highlighter-rouge">string | null</code> because it’s not smart enough to collapse
the overloaded signatures when that’s possible. So we can either add yet another overload signature for the
<code class="language-plaintext highlighter-rouge">string | null</code> case, or we can be like <span style="white-space: nowrap; font-family: sans-serif;">(╯°□°)╯︵
┻━┻</span> and switch to using <strong>conditional types</strong>.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">process</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="nx">text</span><span class="p">:</span> <span class="nx">T</span>
<span class="p">):</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="kr">string</span> <span class="p">?</span> <span class="kr">string</span> <span class="p">:</span> <span class="kc">null</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here we’ve introduced a type variable <code class="language-plaintext highlighter-rouge">T</code> for the <code class="language-plaintext highlighter-rouge">text</code> parameter. We can then use <code class="language-plaintext highlighter-rouge">T</code> as part of a conditional
return type: <code class="language-plaintext highlighter-rouge">T extends string ? string : null</code>. You probably noticed that this looks just like a ternary
expression! Indeed, it’s doing the same kind of thing, but within the type system at compile time.</p>

<p>And that takes care of all our use cases:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typeof</span> <span class="nx">process</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">)</span> <span class="c1">// =&gt; string</span>
<span class="k">typeof</span> <span class="nx">process</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// =&gt; null</span>
<span class="k">typeof</span> <span class="nx">process</span><span class="p">(</span><span class="nx">maybeFoo</span><span class="p">)</span> <span class="c1">// =&gt; string | null</span>
</code></pre></div></div>

<p>So that’s what a conditional type is! A kind of ternary type expression. It always has this form:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A extends B ? C : D
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code>, <code class="language-plaintext highlighter-rouge">C</code>, and <code class="language-plaintext highlighter-rouge">D</code> can be any old type expressions, but all the important stuff is happening on the left there.
In the <code class="language-plaintext highlighter-rouge">A extends B</code> condition.</p>

<h2 id="assignability">Assignability</h2>

<p>This <code class="language-plaintext highlighter-rouge">extends</code> keyword is the heart of a conditional type. <code class="language-plaintext highlighter-rouge">A extends B</code> means precisely that any value of type <code class="language-plaintext highlighter-rouge">A</code>
can safely be assigned to a variable of type <code class="language-plaintext highlighter-rouge">B</code>. In type system jargon we can say that “A is <em>assignable</em> to B”.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">declare</span> <span class="kd">const</span> <span class="nx">a</span><span class="p">:</span> <span class="nx">A</span>
<span class="kd">const</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">B</span> <span class="o">=</span> <span class="nx">a</span>
<span class="c1">// type check succeeds only if A is assignable to B</span>
</code></pre></div></div>

<p>TypeScript decides which types are assignable to each other using an approach called ‘structural typing’. This kind
of type system started appearing in mainstream languages relatively recently (in the last 10 years or so), and
might be a little counterintuitive if you come from a Java or C# background.</p>

<p>You may have heard of ‘duck typing’ in relation to dynamically-typed languages. The phrase ‘duck typing’ comes from
the proverb</p>

<blockquote>
  <p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p>
</blockquote>

<p>In duck typing, you judge a thing by how it behaves, rather than what it is called or who its parents are. It’s a
kind of meritocracy. Structural typing is a way of applying that same idea to a static compile-time type system.</p>

<p>So TypeScript only cares about what types can do, not what they are called or where they exist in a type hierarchy.</p>

<p>Take this simple example:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">A</span> <span class="p">{}</span>
<span class="kd">class</span> <span class="nx">B</span> <span class="p">{}</span>

<span class="kd">const</span> <span class="nx">b</span><span class="p">:</span> <span class="nx">B</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">()</span> <span class="c1">// ✔ all good</span>
<span class="kd">const</span> <span class="nx">a</span><span class="p">:</span> <span class="nx">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">()</span> <span class="c1">// ✔ all good</span>

<span class="k">new</span> <span class="nx">A</span><span class="p">()</span> <span class="k">instanceof</span> <span class="nx">B</span> <span class="c1">// =&gt; false</span>
</code></pre></div></div>

<p>TypeScript is happy treating two completely unrelated classes as equivalent because they have the same <em>structure</em>
and the same <em>capabilities</em>. Meanwhile, when checking the types at runtime, we discover that they are actually not
equivalent.</p>

<p>This is a notable example of where the semantics of TypeScript are at odds with JavaScript. It might seem like a
problem, but in practice structural typing is a lot more flexible than Java-esque ‘nominal’ typing, where names and
hierarchy matter. The two aren’t mutually exclusive, however. Some languages, like Scala and Flow, allow you to mix
and match to suit particular problems.</p>

<p>Aside from that, the way that assignability works with structural typing is very intuitive.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Circle</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="kr">string</span>
  <span class="nx">radius</span><span class="p">:</span> <span class="kr">number</span>
<span class="p">}</span>

<span class="c1">// ✔ All good! Circles have a color</span>
<span class="kd">const</span> <span class="nx">shape</span><span class="p">:</span> <span class="nx">Shape</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Circle</span><span class="p">()</span>
<span class="c1">// ✘ Type error! Not all shapes have a radius!</span>
<span class="kd">const</span> <span class="nx">circle</span><span class="p">:</span> <span class="nx">Circle</span> <span class="o">=</span> <span class="nx">shape</span>
</code></pre></div></div>

<p>Speaking structurally we can say that <code class="language-plaintext highlighter-rouge">A extends B</code> is a lot like ‘<code class="language-plaintext highlighter-rouge">A</code> is a superset of <code class="language-plaintext highlighter-rouge">B</code>’, or, to be more
verbose, ‘<code class="language-plaintext highlighter-rouge">A</code> has all of <code class="language-plaintext highlighter-rouge">B</code>’s properties, <em>and maybe some more</em>’.</p>

<p>There’s one minor caveat though, and that’s with ‘literal’ types. In TypeScript you can use literal values of
primitive types as types themselves.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">fruit</span><span class="p">:</span> <span class="dl">"</span><span class="s2">banana</span><span class="dl">"</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">banana</span><span class="dl">"</span>

<span class="c1">// Type Error! "apple" is not assignable to "banana"</span>
<span class="nx">fruit</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">apple</span><span class="dl">"</span>
</code></pre></div></div>

<p>The string <code class="language-plaintext highlighter-rouge">"banana"</code> doesn’t have more properties than any other <code class="language-plaintext highlighter-rouge">string</code>. But the type <code class="language-plaintext highlighter-rouge">"banana"</code> is still more
<em>specific</em> than the type <code class="language-plaintext highlighter-rouge">string</code>.</p>

<p>So another way to think of <code class="language-plaintext highlighter-rouge">A extends B</code> is like ‘<code class="language-plaintext highlighter-rouge">A</code> is a possibly-more-specific version of <code class="language-plaintext highlighter-rouge">B</code>’.</p>

<p>Which brings us to ‘top’ and ‘bottom’ types: the <em>least</em> and <em>most</em> specific types, respectively.</p>

<p>In type theory a ‘top’ type is one which all other types are assignable to. It is the type you use to say “I have
absolutely no information about what this value is”. Think of it as the union of all possible types:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Top</span> <span class="o">=</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span> <span class="o">|</span> <span class="p">{</span><span class="na">foo</span><span class="p">:</span> <span class="nx">Bar</span><span class="p">}</span> <span class="o">|</span> <span class="nx">Baz</span><span class="p">[]</span> <span class="o">|</span> <span class="p">...</span> <span class="o">|</span> <span class="err">∞</span>
</code></pre></div></div>

<p>TypeScript has two top types: <code class="language-plaintext highlighter-rouge">any</code> and <code class="language-plaintext highlighter-rouge">unknown</code>.</p>

<ul>
  <li>Using <code class="language-plaintext highlighter-rouge">any</code> is like saying “I have no idea what this value looks like. So, TypeScript, please assume I’m using it
correctly, and don’t complain if anything I do seems dangerous”.</li>
  <li>Using <code class="language-plaintext highlighter-rouge">unknown</code> is like saying “I have no idea what this value looks like. So, TypeScript, please make sure I
check what it is capable of at run time.”</li>
</ul>

<p>A ‘bottom’ type is one which no other types are assignable to, and that no values can be an instance of. Think of
it as the empty union type:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Bottom</span> <span class="o">=</span> <span class="err">∅</span>
</code></pre></div></div>

<p>TypeScript has one bottom type: <code class="language-plaintext highlighter-rouge">never</code>. That’s a nice descriptive name because it literally means <em>this can never
happen</em>.</p>

<p>Top and bottom types are useful to know about when working with conditional types. <code class="language-plaintext highlighter-rouge">never</code> is especially useful
when using conditional types to refine unions…</p>

<h2 id="refining-unions-with-distributive-conditional-types">Refining unions with distributive conditional types</h2>

<p>Conditional types let you filter out particular members of a union type. To illustrate, let’s say we have a union
type called <code class="language-plaintext highlighter-rouge">Animal</code>:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Animal</span> <span class="o">=</span> <span class="nx">Lion</span> <span class="o">|</span> <span class="nx">Zebra</span> <span class="o">|</span> <span class="nx">Tiger</span> <span class="o">|</span> <span class="nx">Shark</span>
</code></pre></div></div>

<p>And imagine that we needed to write a function that used only those animals which are also cats. We might write
some helper type called <code class="language-plaintext highlighter-rouge">ExtractCat</code> to do that:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExtractCat</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">A</span> <span class="kd">extends</span> <span class="p">{</span> <span class="nx">meow</span><span class="p">():</span> <span class="k">void</span> <span class="p">}</span> <span class="p">?</span> <span class="nx">A</span> <span class="p">:</span> <span class="nx">never</span>

<span class="kd">type</span> <span class="nx">Cat</span> <span class="o">=</span> <span class="nx">ExtractCat</span><span class="o">&lt;</span><span class="nx">Animal</span><span class="o">&gt;</span>
<span class="c1">// =&gt; Lion | Tiger</span>
</code></pre></div></div>

<p><em>I know lions and tigers don’t meow, but how cute would it be if they did</em> ^_^</p>

<p>This seemed vague and magical to me at first. Let’s see what TypeScript is doing under the hood when it evaluates
<code class="language-plaintext highlighter-rouge">ExtractCat&lt;Animal&gt;</code>.</p>

<p>First, it applies <code class="language-plaintext highlighter-rouge">ExtractCat</code> recursively to all the members of <code class="language-plaintext highlighter-rouge">Animal</code>:</p>

<!-- prettier-ignore -->
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Cat</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nx">ExtractCat</span><span class="o">&lt;</span><span class="nx">Lion</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nx">ExtractCat</span><span class="o">&lt;</span><span class="nx">Zebra</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nx">ExtractCat</span><span class="o">&lt;</span><span class="nx">Tiger</span><span class="o">&gt;</span>
  <span class="o">|</span> <span class="nx">ExtractCat</span><span class="o">&lt;</span><span class="nx">Shark</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Then it evaluates the conditional types:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Cat</span> <span class="o">=</span> <span class="nx">Lion</span> <span class="o">|</span> <span class="nx">never</span> <span class="o">|</span> <span class="nx">Tiger</span> <span class="o">|</span> <span class="nx">never</span>
</code></pre></div></div>

<p>And then something fun happens… Remember that no values can ever be of type <code class="language-plaintext highlighter-rouge">never</code>? That makes it totally
meaningless to include <code class="language-plaintext highlighter-rouge">never</code> in a union type, so TypeScript just gets rid of it.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Cat</span> <span class="o">=</span> <span class="nx">Lion</span> <span class="o">|</span> <span class="nx">Tiger</span>
</code></pre></div></div>

<p>The TypeScript jargon for this kind of conditional type is <strong>distributive conditional type</strong>.</p>

<p>That ‘distribution’, where the union is unrolled recursively, only happens when the thing on the left of the
<code class="language-plaintext highlighter-rouge">extends</code> keyword is a plain type variable. We’ll see what that means and how to work around it in the next
section.</p>

<h2 id="a-real-use-case-for-distributive-conditional-types">A real use-case for distributive conditional types.</h2>

<p>A while ago I was building a Chrome extension. It had a ‘background’ script and a ‘view’ script that ran in
different execution contexts. They needed to communicate and share state, and the only way to do that is via
serializable message passing. I took inspiration from Redux and defined a global union of interfaces called
<code class="language-plaintext highlighter-rouge">Action</code> to model the messages that I wanted to be able to pass between the contexts.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Action</span> <span class="o">=</span>
  <span class="o">|</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">INIT</span><span class="dl">"</span>
    <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">SYNC</span><span class="dl">"</span>
    <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">LOG_IN</span><span class="dl">"</span>
      <span class="na">emailAddress</span><span class="p">:</span> <span class="kr">string</span>
    <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">LOG_IN_SUCCESS</span><span class="dl">"</span>
      <span class="na">accessToken</span><span class="p">:</span> <span class="kr">string</span>
    <span class="p">}</span>
<span class="c1">// ...</span>
</code></pre></div></div>

<p>And then there was a global <code class="language-plaintext highlighter-rouge">dispatch</code> function that I could use directly to broadcast messages across contexts</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">dispatch</span><span class="p">(</span><span class="nx">action</span><span class="p">:</span> <span class="nx">Action</span><span class="p">):</span> <span class="k">void</span>

<span class="c1">// ...</span>

<span class="nx">dispatch</span><span class="p">({</span>
  <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">INIT</span><span class="dl">"</span>
<span class="p">})</span>

<span class="c1">// ...</span>

<span class="nx">dispatch</span><span class="p">({</span>
  <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">LOG_IN</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">emailAddress</span><span class="p">:</span> <span class="dl">"</span><span class="s2">david.sheldrick@artsy.net</span><span class="dl">"</span>
<span class="p">})</span>

<span class="c1">// ...</span>

<span class="nx">dispatch</span><span class="p">({</span>
  <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">LOG_IN_SUCCESS</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">accessToken</span><span class="p">:</span> <span class="dl">"</span><span class="s2">038fh239h923908h</span><span class="dl">"</span>
<span class="p">})</span>
</code></pre></div></div>

<p><a target="_blank" style="font-size: 0.8em" href="https://www.typescriptlang.org/play/#src=type%20Action%20%3D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22INIT%22%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22SYNC%22%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22LOG_IN%22%0D%0A%20%20%20%20%20%20emailAddress%3A%20string%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22LOG_IN_SUCCESS%22%0D%0A%20%20%20%20%20%20accessToken%3A%20string%0D%0A%20%20%20%20%7D%0D%0A%0D%0Adeclare%20function%20dispatch(action%3A%20Action)%3A%20void%0D%0A%0D%0Adispatch(%7B%0D%0A%20%20type%3A%20%22INIT%22%0D%0A%7D)%0D%0A%0D%0Adispatch(%7B%0D%0A%20%20type%3A%20%22LOG_IN%22%2C%0D%0A%20%20emailAddress%3A%20%22david.sheldrick%40artsy.net%22%0D%0A%7D)%0D%0A%0D%0Adispatch(%7B%0D%0A%20%20type%3A%20%22LOG_IN_SUCCESS%22%2C%0D%0A%20%20accessToken%3A%20%22038fh239h923908h%22%0D%0A%7D)">
<em>Try it in the TypeScript playground</em> </a></p>

<p>This API is typesafe and it plays well with my IDE’s autocomplete and I could have left it there. I could have
moved on to other things.</p>

<p>But there’s this little voice inside my head. I think most developers have this voice.</p>

<pre style="background: transparent; color: #333; border: 0; box-shadow: none; padding: 0;">
INT. HIPSTER CO-WORKING SPACE - DAY

DAVID sits on an oddly-shaped orange chair.
His MacBook rests askew on a lumpy reclaimed
wood desk. He stares at colorful text on a
dark screen.

A tiny whisper.

              VOICE (V.O.)
    Psst!

David looks around for a moment and then
stares back at the laptop.

              VOICE (V.O.)
    Psst! Hey!

Startled this time, David looks around
again. He speaks to nobody in particular.

              DAVID
    Is someone there?

              VOICE (V.O.)
    It's me, the DRY devil.

David heaves a painful sigh of recognition.

              DAVID
    Not you again! Leave me alone!

              DRY DEVIL (V.O.)
    DRY stands for "Don't Repeat Yourself"

              DAVID
    I know, you say that every time! Now
    get lost!

              DRY DEVIL (V.O.)
    I've noticed an issue with your code.

              DAVID
    Seriously, go away! I'm busy solving
    user problems to create business value.

              DRY DEVIL (V.O.)
    Every time you call `dispatch` you
    are typing 6 redundant characters.

              DAVID
    Oh snap! You're right! I must fix this.

MONTAGE

David spends the next 2 hours wrestling
with TypeScript, accumulating a pile of
empty coffee cups and protein ball wrappers.
</pre>

<p>We’ve all been there.</p>

<p>I wanted the dispatch function to work like this:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// first argument is the 'type'</span>
<span class="c1">// second is any extra parameters</span>
<span class="nx">dispatch</span><span class="p">(</span><span class="dl">"</span><span class="s2">LOG_IN_SUCCESS</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">accessToken</span><span class="p">:</span> <span class="dl">"</span><span class="s2">038fh239h923908h</span><span class="dl">"</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Deriving the type for that first argument is easy enough.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ActionType</span> <span class="o">=</span> <span class="nx">Action</span><span class="p">[</span><span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">]</span>
<span class="c1">// =&gt; "INIT" | "SYNC" | "LOG_IN" | "LOG_IN_SUCCESS"</span>
</code></pre></div></div>

<p>But the type of the second argument <em>depends on</em> the first argument. We can use a type variable to model that
dependency.</p>

<!-- prettier-ignore -->
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">declare</span> <span class="kd">function</span> <span class="nx">dispatch</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">ActionType</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="kd">type</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span>
  <span class="nx">args</span><span class="p">:</span> <span class="nx">ExtractActionParameters</span><span class="o">&lt;</span><span class="nx">Action</span><span class="p">,</span> <span class="nx">T</span><span class="o">&gt;</span>
<span class="p">):</span> <span class="k">void</span>
</code></pre></div></div>

<p><em>Woah woah woah, what’s this</em> <code class="language-plaintext highlighter-rouge">ExtractActionParameters</code> <em>voodoo?</em></p>

<p>It’s a conditional type of course! Here’s a first attempt at implementing it:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExtractActionParameters</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">A</span> <span class="kd">extends</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="nx">T</span> <span class="p">}</span> <span class="p">?</span> <span class="nx">A</span> <span class="p">:</span> <span class="nx">never</span>
</code></pre></div></div>

<p>This is a lot like the <code class="language-plaintext highlighter-rouge">ExtractCat</code> example from before, where we were were refining the <code class="language-plaintext highlighter-rouge">Animals</code> union by
searching for something that can <code class="language-plaintext highlighter-rouge">meow()</code>. Here, we’re refining the <code class="language-plaintext highlighter-rouge">Action</code> union type by searching for an
interface with a particular <code class="language-plaintext highlighter-rouge">type</code> property. Let’s see if it works:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Test</span> <span class="o">=</span> <span class="nx">ExtractActionParameters</span><span class="o">&lt;</span><span class="nx">Action</span><span class="p">,</span> <span class="dl">"</span><span class="s2">LOG_IN</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="c1">// =&gt; { type: "LOG_IN", emailAddress: string }</span>
</code></pre></div></div>

<p>Almost there! We don’t want to keep the <code class="language-plaintext highlighter-rouge">type</code> field after extraction because then we would still have to specify
it when calling <code class="language-plaintext highlighter-rouge">dispatch</code>. And that would somewhat defeat the purpose of this entire exercise.</p>

<p>We can omit the <code class="language-plaintext highlighter-rouge">type</code> field by combining a <strong>mapped type</strong> with a conditional type and the <code class="language-plaintext highlighter-rouge">keyof</code> operator.</p>

<p>A <strong>mapped type</strong> lets you create a new interface by ‘mapping’ over a union of keys. You can get a union of keys
from an existing interface by using the <code class="language-plaintext highlighter-rouge">keyof</code> operator. And finally, you can remove things from a union using a
conditional type. Here’s how they play together (with some inline test cases for illustration):</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExcludeTypeKey</span><span class="o">&lt;</span><span class="nx">K</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="dl">"</span><span class="s2">type</span><span class="dl">"</span> <span class="p">?</span> <span class="nx">never</span> <span class="p">:</span> <span class="nx">K</span>

<span class="kd">type</span> <span class="nx">Test</span> <span class="o">=</span> <span class="nx">ExcludeTypeKey</span><span class="o">&lt;</span><span class="dl">"</span><span class="s2">emailAddress</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">type</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="c1">// =&gt; "emailAddress" | "foo"</span>

<span class="c1">// here's the mapped type</span>
<span class="kd">type</span> <span class="nx">ExcludeTypeField</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">ExcludeTypeKey</span><span class="o">&lt;</span><span class="kr">keyof</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">]:</span> <span class="nx">A</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">Test</span> <span class="o">=</span> <span class="nx">ExcludeTypeField</span><span class="o">&lt;</span><span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">LOG_IN</span><span class="dl">"</span><span class="p">;</span> <span class="nl">emailAddress</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span><span class="o">&gt;</span>
<span class="c1">// =&gt; { emailAddress: string }</span>
</code></pre></div></div>

<p>Then we can use <code class="language-plaintext highlighter-rouge">ExcludeTypeField</code> to redefine <code class="language-plaintext highlighter-rouge">ExtractActionParameters</code>.</p>

<!-- prettier-ignore -->
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExtractActionParameters</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">A</span> <span class="kd">extends</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="nx">T</span> <span class="p">}</span>
  <span class="p">?</span> <span class="nx">ExcludeTypeField</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span>
  <span class="p">:</span> <span class="nx">never</span>
</code></pre></div></div>

<p>And now the new version of <code class="language-plaintext highlighter-rouge">dipsatch</code> is typesafe!</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// All clear! :)</span>
<span class="nx">dispatch</span><span class="p">(</span><span class="dl">"</span><span class="s2">LOG_IN_SUCCESS</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">accessToken</span><span class="p">:</span> <span class="dl">"</span><span class="s2">038fh239h923908h</span><span class="dl">"</span>
<span class="p">})</span>

<span class="nx">dispatch</span><span class="p">(</span><span class="dl">"</span><span class="s2">LOG_IN_SUCCESS</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="c1">// Type Error! :)</span>
  <span class="na">badKey</span><span class="p">:</span> <span class="dl">"</span><span class="s2">038fh239h923908h</span><span class="dl">"</span>
<span class="p">})</span>

<span class="c1">// Type Error! :)</span>
<span class="nx">dispatch</span><span class="p">(</span><span class="dl">"</span><span class="s2">BAD_TYPE</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">accessToken</span><span class="p">:</span> <span class="dl">"</span><span class="s2">038fh239h923908h</span><span class="dl">"</span>
<span class="p">})</span>
</code></pre></div></div>

<p><a target="_blank" style="font-size: 0.8em" href="https://www.typescriptlang.org/play/#src=type%20Action%20%3D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22INIT%22%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22SYNC%22%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22LOG_IN%22%0D%0A%20%20%20%20%20%20emailAddress%3A%20string%0D%0A%20%20%20%20%7D%0D%0A%20%20%7C%20%7B%0D%0A%20%20%20%20%20%20type%3A%20%22LOG_IN_SUCCESS%22%0D%0A%20%20%20%20%20%20accessToken%3A%20string%0D%0A%20%20%20%20%7D%0D%0A%0D%0Atype%20ActionType%20%3D%20Action%5B%22type%22%5D%0D%0A%0D%0Adeclare%20function%20dispatch%3CT%20extends%20ActionType%3E(%0D%0A%20%20%20%20type%3A%20T%2C%0D%0A%20%20%20%20args%3A%20ExtractActionParameters%3CAction%2C%20T%3E%0D%0A)%3A%20void%0D%0A%0D%0Atype%20ExcludeTypeKey%3CK%3E%20%3D%20K%20extends%20%22type%22%20%3F%20never%20%3A%20K%0D%0A%0D%0Atype%20ExcludeTypeField%3CA%3E%20%3D%20%7B%20%5BK%20in%20ExcludeTypeKey%3Ckeyof%20A%3E%5D%3A%20A%5BK%5D%20%7D%0D%0A%0D%0Atype%20ExtractActionParameters%3CA%2C%20T%3E%20%3D%20A%20extends%20%7B%20type%3A%20T%20%7D%0D%0A%20%20%20%20%3F%20ExcludeTypeField%3CA%3E%0D%0A%20%20%20%20%3A%20never%0D%0A%20%20%0D%0A%2F%2F%20All%20clear!%20%3A)%0D%0Adispatch(%22LOG_IN_SUCCESS%22%2C%20%7B%0D%0A%20%20%20%20accessToken%3A%20%22038fh239h923908h%22%0D%0A%7D)%0D%0A%0D%0Adispatch(%22LOG_IN_SUCCESS%22%2C%20%7B%0D%0A%20%20%20%20%2F%2F%20Type%20Error!%20%3A)%0D%0A%20%20%20%20badKey%3A%20%22038fh239h923908h%22%0D%0A%7D)%0D%0A%0D%0A%2F%2F%20Type%20Error!%20%3A)%0D%0Adispatch(%22BAD_TYPE%22%2C%20%7B%0D%0A%20%20%20%20accessToken%3A%20%22038fh239h923908h%22%0D%0A%7D)">
<em>Try it in the TypeScript playground</em> </a></p>

<p>But there’s one more very serious problem to address: If the action has no extra parameters, I still have to pass a
second empty argument.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">dispatch</span><span class="p">(</span><span class="dl">"</span><span class="s2">INIT</span><span class="dl">"</span><span class="p">,</span> <span class="p">{})</span>
</code></pre></div></div>

<p>That’s four whole wasted characters! Cancel my meetings and tell my partner not to wait up tonight! We need to
<em>fix. this</em>.</p>

<p>The naïve thing to do would be to make the second argument optional. That would be unsafe because, e.g. it would
allow us to dispatch a <code class="language-plaintext highlighter-rouge">"LOG_IN"</code> action without specifying an <code class="language-plaintext highlighter-rouge">emailAddress</code>.</p>

<p>Instead, let’s overload the <code class="language-plaintext highlighter-rouge">dispatch</code> function.</p>

<!-- prettier-ignore -->
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// And let's say that any actions that don't require</span>
<span class="c1">// extra parameters are 'simple' actions.</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">dispatch</span><span class="p">(</span><span class="kd">type</span><span class="p">:</span> <span class="nx">SimpleActionType</span><span class="p">):</span> <span class="k">void</span>
<span class="c1">// this signature is just like before</span>
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">dispatch</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">ActionType</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="kd">type</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span>
  <span class="nx">args</span><span class="p">:</span> <span class="nx">ExtractActionParameters</span><span class="o">&lt;</span><span class="nx">Action</span><span class="p">,</span> <span class="nx">T</span><span class="o">&gt;</span>
<span class="p">):</span> <span class="k">void</span>

<span class="kd">type</span> <span class="nx">SimpleActionType</span> <span class="o">=</span> <span class="nx">ExtractSimpleAction</span><span class="o">&lt;</span><span class="nx">Action</span><span class="o">&gt;</span><span class="p">[</span><span class="dl">'</span><span class="s1">type</span><span class="dl">'</span><span class="p">]</span>
</code></pre></div></div>

<p>How can we define this <code class="language-plaintext highlighter-rouge">ExtractSimpleAction</code> conditional type? We know that if we remove the <code class="language-plaintext highlighter-rouge">type</code> field from an
action and the result is an empty interface, then that is a simple action. So something like this might work</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExtractSimpleAction</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">ExcludeTypeField</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="p">{}</span> <span class="p">?</span> <span class="nx">A</span> <span class="p">:</span> <span class="nx">never</span>
</code></pre></div></div>

<p>Except that doesn’t work. <code class="language-plaintext highlighter-rouge">ExcludeTypeField&lt;A&gt; extends {}</code> is always going to be true, because <code class="language-plaintext highlighter-rouge">{}</code> is like a top
type for interfaces. <em>Pretty much everything</em> is more specific than <code class="language-plaintext highlighter-rouge">{}</code>.</p>

<p>We need to swap the arguments around:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExtractSimpleAction</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{}</span> <span class="kd">extends</span> <span class="nx">ExcludeTypeField</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="p">?</span> <span class="nx">A</span> <span class="p">:</span> <span class="nx">never</span>
</code></pre></div></div>

<p>Now if <code class="language-plaintext highlighter-rouge">ExcludeTypeField&lt;A&gt;</code> is empty, the condition will be true, otherwise it will be false.</p>

<p>But this still doesn’t work! On-the-ball readers might remember this:</p>

<blockquote>
  <p>That ‘distribution’, where the union is unrolled recursively, only happens when the thing on the left of the
<code class="language-plaintext highlighter-rouge">extends</code> keyword is a plain type variable. We’ll see what that means and how to work around it in the next
section.</p>
</blockquote>

<p>– Me, in the previous section</p>

<p>Type variables are always defined in a generic parameter list, delimited by <code class="language-plaintext highlighter-rouge">&lt;</code> and <code class="language-plaintext highlighter-rouge">&gt;</code>. e.g.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Blah</span><span class="o">&lt;</span><span class="nx">These</span><span class="p">,</span> <span class="nx">Are</span><span class="p">,</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">Variables</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">...</span>

<span class="kd">function</span> <span class="nx">blah</span><span class="o">&lt;</span><span class="nx">And</span><span class="p">,</span> <span class="nx">So</span><span class="p">,</span> <span class="nx">Are</span><span class="p">,</span> <span class="nx">These</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And if you want a conditional type to distribute over a union, the union a) needs to have been bound to a type
variable, and b) that variable needs to appear alone to the left of the <code class="language-plaintext highlighter-rouge">extends</code> keyword.</p>

<p>e.g. this is a distributive conditional type:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Blah</span><span class="o">&lt;</span><span class="nx">Var</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">Var</span> <span class="kd">extends</span> <span class="nx">Whatever</span> <span class="p">?</span> <span class="nx">A</span> <span class="p">:</span> <span class="nx">B</span>
</code></pre></div></div>

<p>and these are not:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Blah</span><span class="o">&lt;</span><span class="nx">Var</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">Foo</span><span class="o">&lt;</span><span class="nx">Var</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nx">Whatever</span> <span class="p">?</span> <span class="nx">A</span> <span class="p">:</span> <span class="nx">B</span>
<span class="kd">type</span> <span class="nx">Blah</span><span class="o">&lt;</span><span class="nx">Var</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">Whatever</span> <span class="kd">extends</span> <span class="nx">Var</span> <span class="p">?</span> <span class="nx">A</span> <span class="p">:</span> <span class="nx">B</span>
</code></pre></div></div>

<p>When I discovered this limitation I thought that it exposed a fundamental shortcoming in the way distributive
conditional types work under the hood. I thought it might be some kind of concession to algorithmic complexity. I
thought that my use case was too advanced, and that TypeScript had just thrown its hands up in the air and said,
“Sorry mate, you’re on your own”.</p>

<p>But it turns out I was wrong. It is just a pragmatic language design decision to avoid extra syntax, and you can
work around it easily:</p>

<!-- prettier-ignore -->
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExtractSimpleAction</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">A</span> <span class="kd">extends</span> <span class="kr">any</span>
  <span class="p">?</span> <span class="p">{}</span> <span class="kd">extends</span> <span class="nx">ExcludeTypeField</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span>
    <span class="p">?</span> <span class="nx">A</span>
    <span class="p">:</span> <span class="nx">never</span>
  <span class="p">:</span> <span class="nx">never</span>
</code></pre></div></div>

<p>All we did is wrap the meat of our logic in a flimsy tortilla of inevitability, since the outer condition
<code class="language-plaintext highlighter-rouge">A extends any</code> will, of course, always be true.</p>

<p>And finally we can delete those four characters 🎉🕺🏼💃🏽🎈</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">dispatch</span><span class="p">(</span><span class="dl">"</span><span class="s2">INIT</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>That’s one yak successfully shaved ✔</p>

<hr />

<p>TypeScript provides a couple of built-in types that we could have used in this section:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Exclude from U those types that are assignable to T</span>
<span class="kd">type</span> <span class="nx">Exclude</span><span class="o">&lt;</span><span class="nx">U</span><span class="p">,</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">U</span> <span class="kd">extends</span> <span class="nx">T</span> <span class="p">?</span> <span class="nx">never</span> <span class="p">:</span> <span class="nx">U</span>

<span class="c1">// Extract from U those types that are assignable to T</span>
<span class="kd">type</span> <span class="nx">Extract</span><span class="o">&lt;</span><span class="nx">U</span><span class="p">,</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">U</span> <span class="kd">extends</span> <span class="nx">T</span> <span class="p">?</span> <span class="nx">U</span> <span class="p">:</span> <span class="nx">never</span>
</code></pre></div></div>

<p>e.g. instead of defining <code class="language-plaintext highlighter-rouge">ExcludeTypeField</code> like this:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExcludeTypeField</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">ExcludeTypeKey</span><span class="o">&lt;</span><span class="kr">keyof</span> <span class="nx">A</span><span class="o">&gt;</span><span class="p">]:</span> <span class="nx">A</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div></div>

<p>we could have done this:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExcludeTypeField</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">Exclude</span><span class="o">&lt;</span><span class="kr">keyof</span> <span class="nx">A</span><span class="p">,</span> <span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="o">&gt;</span><span class="p">]:</span> <span class="nx">A</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div></div>

<p>And instead of defining <code class="language-plaintext highlighter-rouge">ExtractActionParameters</code> like this:</p>

<!-- prettier-ignore -->
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExtractActionParameters</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">A</span> <span class="kd">extends</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="nx">T</span> <span class="p">}</span>
  <span class="p">?</span> <span class="nx">ExcludeTypeField</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span>
  <span class="p">:</span> <span class="nx">never</span>
</code></pre></div></div>

<p>we could have done this:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ExtractActionParameters</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">ExcludeTypeField</span><span class="o">&lt;</span><span class="nx">Extract</span><span class="o">&lt;</span><span class="nx">A</span><span class="p">,</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="nx">T</span> <span class="p">}</span><span class="o">&gt;&gt;</span>
</code></pre></div></div>

<h2 id="-exercise-for-the-intrepid-reader">💡 Exercise for the intrepid reader</h2>

<p>Notice that this still works.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">dispatch</span><span class="p">(</span><span class="dl">"</span><span class="s2">INIT</span><span class="dl">"</span><span class="p">,</span> <span class="p">{})</span>
</code></pre></div></div>

<p>Use what you’ve learned so far to make it an error to supply a second argument for ‘simple’ actions.</p>

<h2 id="destructuring-types-with-infer">Destructuring types with <code class="language-plaintext highlighter-rouge">infer</code></h2>

<p>Conditional types have another trick up their sleeve: the <code class="language-plaintext highlighter-rouge">infer</code> keyword. It can be used anywhere in the type
expression to the right of the <code class="language-plaintext highlighter-rouge">extends</code> keyword. It gives a name to whichever type would appear in that place.
e.g.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Unpack</span><span class="o">&lt;</span><span class="nx">A</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">A</span> <span class="kd">extends</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">infer</span> <span class="nx">E</span><span class="o">&gt;</span> <span class="p">?</span> <span class="nx">E</span> <span class="p">:</span> <span class="nx">A</span>

<span class="kd">type</span> <span class="nx">Test</span> <span class="o">=</span> <span class="nx">Unpack</span><span class="o">&lt;</span><span class="nx">Apple</span><span class="p">[]</span><span class="o">&gt;</span>
<span class="c1">// =&gt; Apple</span>
<span class="kd">type</span> <span class="nx">Test</span> <span class="o">=</span> <span class="nx">Unpack</span><span class="o">&lt;</span><span class="nx">Apple</span><span class="o">&gt;</span>
<span class="c1">// =&gt; Apple</span>
</code></pre></div></div>

<p>It handles ambiguity gracefully:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Stairs</span> <span class="o">=</span> <span class="nx">Unpack</span><span class="o">&lt;</span><span class="nx">Apple</span><span class="p">[]</span> <span class="o">|</span> <span class="nx">Pear</span><span class="p">[]</span><span class="o">&gt;</span>
<span class="c1">// =&gt; Apple | Pear</span>
</code></pre></div></div>

<p>You can even use <code class="language-plaintext highlighter-rouge">infer</code> multiple times.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Flip</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="p">[</span><span class="nx">infer</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">infer</span> <span class="nx">B</span><span class="p">]</span> <span class="p">?</span> <span class="p">[</span><span class="nx">B</span><span class="p">,</span> <span class="nx">A</span><span class="p">]</span> <span class="p">:</span> <span class="nx">never</span>
<span class="kd">type</span> <span class="nx">Stairs</span> <span class="o">=</span> <span class="nx">Flip</span><span class="o">&lt;</span><span class="p">[</span><span class="nx">Pear</span><span class="p">,</span> <span class="nx">Apple</span><span class="p">]</span><span class="o">&gt;</span>
<span class="c1">// =&gt; [Apple, Pear]</span>

<span class="kd">type</span> <span class="nx">Union</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="p">[</span><span class="nx">infer</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">infer</span> <span class="nx">A</span><span class="p">]</span> <span class="p">?</span> <span class="nx">A</span> <span class="p">:</span> <span class="nx">never</span>
<span class="kd">type</span> <span class="nx">Stairs</span> <span class="o">=</span> <span class="nx">Union</span><span class="o">&lt;</span><span class="p">[</span><span class="nx">Apple</span><span class="p">,</span> <span class="nx">Pear</span><span class="p">]</span><span class="o">&gt;</span>
<span class="c1">// =&gt; Apple | Pear</span>
</code></pre></div></div>

<h2 id="other-built-in-conditional-types">Other built-in conditional types</h2>

<p>We’ve already seen <code class="language-plaintext highlighter-rouge">Exclude</code> and <code class="language-plaintext highlighter-rouge">Extract</code>, and TypeScript provides a few other conditional types out of the box.</p>

<!-- prettier-ignore -->
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Exclude null and undefined from T</span>
<span class="kd">type</span> <span class="nx">NonNullable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span>
  <span class="nx">T</span> <span class="kd">extends</span> <span class="kc">null</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">?</span> <span class="nx">never</span> <span class="p">:</span> <span class="nx">T</span>

<span class="c1">// Obtain the parameters of a function type in a tuple</span>
<span class="kd">type</span> <span class="nx">Parameters</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span>
  <span class="nx">T</span> <span class="kd">extends</span> <span class="p">(...</span><span class="nx">args</span><span class="p">:</span> <span class="nx">infer</span> <span class="nx">P</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">any</span> <span class="p">?</span> <span class="nx">P</span> <span class="p">:</span> <span class="nx">never</span>

<span class="c1">// Obtain the parameters of a constructor function type in a tuple</span>
<span class="kd">type</span> <span class="nx">ConstructorParameters</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span>
  <span class="nx">T</span> <span class="kd">extends</span> <span class="k">new</span> <span class="p">(...</span><span class="nx">args</span><span class="p">:</span> <span class="nx">infer</span> <span class="nx">P</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">any</span> <span class="p">?</span> <span class="nx">P</span> <span class="p">:</span> <span class="nx">never</span>

<span class="c1">// Obtain the return type of a function type</span>
<span class="kd">type</span> <span class="nx">ReturnType</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span>
  <span class="nx">T</span> <span class="kd">extends</span> <span class="p">(...</span><span class="nx">args</span><span class="p">:</span> <span class="kr">any</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="nx">infer</span> <span class="nx">R</span> <span class="p">?</span> <span class="nx">R</span> <span class="p">:</span> <span class="kr">any</span>

<span class="c1">// Obtain the return type of a constructor function type</span>
<span class="kd">type</span> <span class="nx">InstanceType</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span>
  <span class="nx">T</span> <span class="kd">extends</span> <span class="k">new</span> <span class="p">(...</span><span class="nx">args</span><span class="p">:</span> <span class="kr">any</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="nx">infer</span> <span class="nx">R</span> <span class="p">?</span> <span class="nx">R</span> <span class="p">:</span> <span class="kr">any</span>
</code></pre></div></div>

<h2 id="further-reading">Further reading</h2>

<ul>
  <li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html">TypeScript 2.8 release notes</a></li>
  <li><a href="https://github.com/Microsoft/TypeScript/pull/21316">Microsoft/Typescript#21316</a> Conditional types pull request</li>
  <li><a href="https://github.com/Microsoft/TypeScript/pull/21496">Microsoft/Typescript#21496</a> <code class="language-plaintext highlighter-rouge">infer</code> pull request</li>
  <li><a href="https://github.com/Microsoft/TypeScript/blob/a2205ad53d8f65a129a552b752d1e06fee3d41fc/lib/lib.es5.d.ts#L1446">lib.es5.d.ts#L1446</a>
built-in conditional type definitions</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Announcing: Artsy x React Native]]></title>
    <link href="https://artsy.github.io/blog/2018/06/03/Announcing-Artsy-x-React-Native/"/>
    <updated>2018-06-03T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2018/06/03/Announcing-Artsy-x-React-Native</id>
    <content type="html"><![CDATA[<p>React Native has a lot of buzz around it. It is some serious and cool tech, yet can feel like a big departure from
your native iOS codebase. At Artsy, we like it. It has been the right choice for us. We’ve <a href="http://artsy.github.io/search/?q=react+native">documented</a> <a href="http://artsy.github.io/series/react-native-at-artsy/">our</a>
<a href="http://artsy.github.io/blog/2016/08/15/React-Native-at-Artsy/">journey</a> and <a href="http://artsy.github.io/blog/2018/03/17/two-years-of-react-native/">reasoning</a> quite extensively, but naturally, developers around the world are still wondering
whether the trade-offs make sense to <em>their</em> team, and <em>their</em> situation.</p>

<p>Enter <a href="https://www.artsy.net/x-react-native">Artsy x React-Native</a>.</p>

<p>Who better to partner with than Facebook? We’re bringing a day full of hands-on informative insight and practical
play. With the focus on what building world class applications with RN can be like.</p>

<p>We’ll demo, through talks and workshops, how to add React Native bit by bit to an existing codebase, set your
tooling up for success, and create solid animations.</p>

<p>We want <a href="https://www.artsy.net/x-react-native">Artsy x React-Native</a> to be about getting you up to speed with the framework, so you can make your
own decisions going forward.</p>

]]></content>
  </entry>
  
</feed>
